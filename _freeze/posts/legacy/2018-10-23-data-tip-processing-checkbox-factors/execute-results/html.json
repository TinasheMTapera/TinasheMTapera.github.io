{
  "hash": "7940d236d57ca3075fafa15d80fb45af",
  "result": {
    "markdown": "---\ntitle: 'Data Tip: Processing Checkbox-Factors'\nauthor: Tinashe M. Tapera\ndate: '2018-10-23'\nslug: data-tip-processing-checkbox-factors\ncategories:\n  - dplyr\n  - data science\ntags:\n  - dplyr\n  - data science\n# comments: no\nshowcomments: yes\nshowpagemeta: yes\n---\n\n\nThe other day I was tasked with processing some data that had been generated from a survey that included checkboxes. You know, the \"tick all that apply\", kind of questions. Nothing against this style of response, it can be quite effective for collecting unbiased data. However, platforms such as Qualtrics annoyingly make it such that checkbox responses are output as *singular concatenated strings per response!*\n\nLet's take a look at what this might look like, using the `Star Wars` dataset in the most recent version of `dplyr`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::starwars\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 87 × 14\n   name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵\n   <chr>        <int> <dbl> <chr>   <chr>   <chr>     <dbl> <chr> <chr>  <chr>  \n 1 Luke Skywa…    172    77 blond   fair    blue       19   male  mascu… Tatooi…\n 2 C-3PO          167    75 <NA>    gold    yellow    112   none  mascu… Tatooi…\n 3 R2-D2           96    32 <NA>    white,… red        33   none  mascu… Naboo  \n 4 Darth Vader    202   136 none    white   yellow     41.9 male  mascu… Tatooi…\n 5 Leia Organa    150    49 brown   light   brown      19   fema… femin… Aldera…\n 6 Owen Lars      178   120 brown,… light   blue       52   male  mascu… Tatooi…\n 7 Beru White…    165    75 brown   light   blue       47   fema… femin… Tatooi…\n 8 R5-D4           97    32 <NA>    white,… red        NA   none  mascu… Tatooi…\n 9 Biggs Dark…    183    84 black   light   brown      24   male  mascu… Tatooi…\n10 Obi-Wan Ke…    182    77 auburn… fair    blue-g…    57   male  mascu… Stewjon\n# … with 77 more rows, 4 more variables: species <chr>, films <list>,\n#   vehicles <list>, starships <list>, and abbreviated variable names\n#   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld\n# ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names\n```\n:::\n\n```{.r .cell-code}\nsw = dplyr::starwars\n```\n:::\n\n\nThe variable `skin_color` is a good candidate for us to learn how to process this type of response. In this variable, Obi-Wan's hair colour is listed as \"auburn, white\", which would be like checking two boxes in a survey. In order to get, for example, a count of how many people listed \"white\" as their hair colour, how would we deal with this column?\n\nYou could do it in base R by enumerating all of the different strings and checking if the row contains any:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# one moment I will give it up to python,\n# R does not have any base objects for dictionaries\n# or set-like collections\n\nmy_colours = list() \n\nfor(character in 1:nrow(sw)){\n  \n  current_colours = sw$skin_color[character]\n  current_colours = trimws(unlist(strsplit(current_colours,split = \",\")))\n  \n  my_colours = append(my_colours, current_colours)\n}\n\nmy_colours = unique(unlist(my_colours))\nmy_colours\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"fair\"          \"gold\"          \"white\"         \"blue\"         \n [5] \"light\"         \"red\"           \"unknown\"       \"green\"        \n [9] \"green-tan\"     \"brown\"         \"pale\"          \"metal\"        \n[13] \"dark\"          \"brown mottle\"  \"grey\"          \"mottled green\"\n[17] \"orange\"        \"yellow\"        \"tan\"           \"silver\"       \n[21] \"none\"         \n```\n:::\n:::\n\n\nNow we have all of the possible values. To see which rows contain one of the values, we have to create an empty dataframe and iterate over the original:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create the dataframe\nsw_colours = data.frame(matrix(nrow = 0, ncol = length(my_colours)))\nnames(sw_colours) = my_colours\n\n# iterate over the original data frame counting hits for each\nfor(character in 1:nrow(sw)){\n  \n  hits = sapply(names(sw_colours), function(x) grepl(x, sw$skin_color[character]), USE.NAMES = FALSE)\n  sw_colours[character,] = hits\n}\n```\n:::\n\n\nAnd there you have it, join these two by name:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsw_colours$name = sw$name\nsw_with_checkboxes = merge(sw, sw_colours, by = \"name\")\nhead(sw_with_checkboxes[,c(\"name\", names(sw_colours))])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                 name  fair  gold white  blue light   red unknown green\n1              Ackbar FALSE FALSE FALSE FALSE FALSE FALSE   FALSE FALSE\n2          Adi Gallia FALSE FALSE FALSE FALSE FALSE FALSE   FALSE FALSE\n3    Anakin Skywalker  TRUE FALSE FALSE FALSE FALSE FALSE   FALSE FALSE\n4        Arvel Crynyd  TRUE FALSE FALSE FALSE FALSE FALSE   FALSE FALSE\n5         Ayla Secura FALSE FALSE FALSE  TRUE FALSE FALSE   FALSE FALSE\n6 Bail Prestor Organa FALSE FALSE FALSE FALSE FALSE FALSE   FALSE FALSE\n  green-tan brown  pale metal  dark brown mottle  grey mottled green orange\n1     FALSE  TRUE FALSE FALSE FALSE         TRUE FALSE         FALSE  FALSE\n2     FALSE FALSE FALSE FALSE  TRUE        FALSE FALSE         FALSE  FALSE\n3     FALSE FALSE FALSE FALSE FALSE        FALSE FALSE         FALSE  FALSE\n4     FALSE FALSE FALSE FALSE FALSE        FALSE FALSE         FALSE  FALSE\n5     FALSE FALSE FALSE FALSE FALSE        FALSE FALSE         FALSE  FALSE\n6     FALSE FALSE FALSE FALSE FALSE        FALSE FALSE         FALSE  FALSE\n  yellow   tan silver  none              name.1\n1  FALSE FALSE  FALSE FALSE              Ackbar\n2  FALSE FALSE  FALSE FALSE          Adi Gallia\n3  FALSE FALSE  FALSE FALSE    Anakin Skywalker\n4  FALSE FALSE  FALSE FALSE        Arvel Crynyd\n5  FALSE FALSE  FALSE FALSE         Ayla Secura\n6  FALSE  TRUE  FALSE FALSE Bail Prestor Organa\n```\n:::\n:::\n\n\nAdmittedly, this is all quite long-winded and could even have been done better. But fortunately, someone has already tackled this problem, and the solution is available on CRAN: The `splitstackshape` package.\n\n\n\n\n\nThis package has handy function `concat.split()` and variants for our case:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsw_expanded=concat.split(sw, \"skin_color\", structure=\"expanded\", type=\"character\", fill = 0)\nhead(select(sw_expanded, name, matches(\"skin_color\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            name  skin_color skin_color_blue skin_color_brown\n1 Luke Skywalker        fair               0                0\n2          C-3PO        gold               0                0\n3          R2-D2 white, blue               1                0\n4    Darth Vader       white               0                0\n5    Leia Organa       light               0                0\n6      Owen Lars       light               0                0\n  skin_color_brown mottle skin_color_dark skin_color_fair skin_color_gold\n1                       0               0               1               0\n2                       0               0               0               1\n3                       0               0               0               0\n4                       0               0               0               0\n5                       0               0               0               0\n6                       0               0               0               0\n  skin_color_green skin_color_green-tan skin_color_grey skin_color_light\n1                0                    0               0                0\n2                0                    0               0                0\n3                0                    0               0                0\n4                0                    0               0                0\n5                0                    0               0                1\n6                0                    0               0                1\n  skin_color_metal skin_color_mottled green skin_color_none skin_color_orange\n1                0                        0               0                 0\n2                0                        0               0                 0\n3                0                        0               0                 0\n4                0                        0               0                 0\n5                0                        0               0                 0\n6                0                        0               0                 0\n  skin_color_pale skin_color_red skin_color_silver skin_color_tan\n1               0              0                 0              0\n2               0              0                 0              0\n3               0              0                 0              0\n4               0              0                 0              0\n5               0              0                 0              0\n6               0              0                 0              0\n  skin_color_unknown skin_color_white skin_color_yellow\n1                  0                0                 0\n2                  0                0                 0\n3                  0                1                 0\n4                  0                1                 0\n5                  0                0                 0\n6                  0                0                 0\n```\n:::\n:::\n\n\nEasy peasy!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}